require('dotenv').config();
const { Telegraf } = require('telegraf');
const { ethers } = require('ethers');
const { verifyPayment, storeProphecyOnChain, finalizeProphecy, payoutWinner } = require('./blockchain');
const fs = require('fs');
const sqlite3 = require('sqlite3').verbose();
const provider = new ethers.JsonRpcProvider(process.env.MONAD_RPC_URL);
const bot = new Telegraf(process.env.TELEGRAM_BOT_TOKEN);
const userStates = new Map();
const dbPath = 'prophecies.db';
const cacheFile = 'prophecies_cache.json';

// SECURITY: Only set announcement chat from GROUP messages, never DMs
let ANNOUNCEMENT_CHAT_ID = null;
// SECURITY: In-memory lock to prevent double-payout race condition
const processingProphecies = new Set();
// SECURITY: Per-user cooldown to prevent /predict spam and AI quota abuse
const userCooldowns = new Map();
const PREDICT_COOLDOWN_MS = 60 * 1000;
// SECURITY: Per-user cooldown for /check to prevent abuse
const checkCooldowns = new Map();
const CHECK_COOLDOWN_MS = 30 * 1000;
// SECURITY: Admin ID for manual overrides (add ADMIN_TELEGRAM_ID to .env)
const ADMIN_TELEGRAM_ID = parseInt(process.env.ADMIN_TELEGRAM_ID) || 0;

// SQLite DB ‚Äî ACID compliant, no JSON corruption risk
let sqldb;
function initDB() {
    sqldb = new sqlite3.Database(dbPath);
    sqldb.serialize(() => {
        sqldb.run(`CREATE TABLE IF NOT EXISTS prophecies (
            id INTEGER PRIMARY KEY,
            userWallet TEXT,
            username TEXT,
            userId INTEGER,
            chatId INTEGER,
            prediction TEXT,
            deadline TEXT,
            deadlineHuman TEXT,
            text TEXT,
            verified INTEGER DEFAULT 0,
            verificationResult TEXT,
            rawVerification TEXT,
            payoutSent INTEGER DEFAULT 0,
            payoutMethod TEXT,
            payoutFailed INTEGER DEFAULT 0,
            isProcessing INTEGER DEFAULT 0,
            onChainId INTEGER,
            timestamp TEXT,
            paymentTx TEXT
        )`);
    });
}
initDB();

// SECURITY: Parameterized queries prevent SQL injection
const getDB = () => {
    return new Promise((resolve) => {
        sqldb.all("SELECT * FROM prophecies ORDER BY id ASC", [], (err, rows) => {
            if (err) { console.error('DB read error:', err.message); resolve([]); return; }
            resolve(rows.map(row => ({
                ...row,
                verified: !!row.verified,
                payoutSent: !!row.payoutSent,
                isProcessing: !!row.isProcessing,
                payoutFailed: !!row.payoutFailed,
                verificationResult: (() => { try { return JSON.parse(row.verificationResult || '{}'); } catch(e) { return {}; } })(),
                rawVerification: (() => { try { return JSON.parse(row.rawVerification || '[]'); } catch(e) { return []; } })()
            })));
        });
    });
};

// SECURITY: Transactional writes for atomicity and crash safety
const saveDB = (data) => {
    return new Promise((resolve) => {
        sqldb.serialize(() => {
            sqldb.run("BEGIN TRANSACTION");
            sqldb.run("DELETE FROM prophecies", [], (err) => {
                if (err) {
                    sqldb.run("ROLLBACK");
                    console.error('DB clear error:', err.message);
                    resolve(); return;
                }
                const stmt = sqldb.prepare(`INSERT INTO prophecies
                    (id, userWallet, username, userId, chatId, prediction, deadline, deadlineHuman,
                     text, verified, verificationResult, rawVerification, payoutSent, payoutMethod,
                     payoutFailed, isProcessing, onChainId, timestamp, paymentTx)
                    VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)`);
                data.forEach(p => {
                    stmt.run(
                        p.id, p.userWallet, p.username, p.userId, p.chatId,
                        p.prediction, p.deadline, p.deadlineHuman, p.text,
                        p.verified ? 1 : 0,
                        JSON.stringify(p.verificationResult || {}),
                        JSON.stringify(p.rawVerification || []),
                        p.payoutSent ? 1 : 0, p.payoutMethod,
                        p.payoutFailed ? 1 : 0, p.isProcessing ? 1 : 0,
                        p.onChainId, p.timestamp, p.paymentTx
                    );
                });
                stmt.finalize();
                sqldb.run("COMMIT", (err) => {
                    if (err) console.error('DB commit error:', err.message);
                    // Backup rotation
                    for (let i = 2; i >= 0; i--) {
                        const oldB = `${dbPath}.backup${i}`;
                        const newB = `${dbPath}.backup${i+1}`;
                        if (fs.existsSync(oldB)) fs.renameSync(oldB, newB);
                    }
                    try { fs.copyFileSync(dbPath, `${dbPath}.backup0`); } catch(e) {}
                    // Write JSON cache for sync reads (leaderboard)
                    try { fs.writeFileSync(cacheFile, JSON.stringify(data)); } catch(e) {}
                    resolve();
                });
            });
        });
    });
};

// Sync read for non-critical paths (leaderboard display)
function getDBSync() {
    try { return JSON.parse(fs.readFileSync(cacheFile, 'utf8') || '[]'); }
    catch(e) { return []; }
}

// SECURITY: Sanitize HTML to prevent Telegram parse errors
function escapeHTML(str) {
    if (!str) return '';
    return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;");
}

// SECURITY: Escape Markdown special characters
function escapeMD(str) {
    if (!str) return '';
    return str.replace(/[_*`[]/g, '\\$&');
}

function setAnnouncementChat(ctx) {
    if (ctx.chat.type === 'group' || ctx.chat.type === 'supergroup') {
        ANNOUNCEMENT_CHAT_ID = ctx.chat.id;
        console.log(`üì¢ Announcement chat set to GROUP: ${ANNOUNCEMENT_CHAT_ID}`);
    } else if (!ANNOUNCEMENT_CHAT_ID) {
        ANNOUNCEMENT_CHAT_ID = ctx.chat.id;
        console.log(`üì¢ Announcement chat set to PRIVATE (fallback): ${ANNOUNCEMENT_CHAT_ID}`);
    }
}

function buildLeaderboard() {
    const db = getDBSync();
    const stats = {};
    for (const p of db) {
        const key = p.username || p.userWallet?.slice(0, 8) || 'Unknown';
        if (!stats[key]) stats[key] = { name: key, total: 0, correct: 0, pending: 0 };
        stats[key].total++;
        const vr = p.verificationResult || {};
        if (p.verified && vr.isCorrect) stats[key].correct++;
        if (!p.verified) stats[key].pending++;
    }
    return Object.values(stats)
        .sort((a, b) => b.correct - a.correct || b.total - a.total)
        .slice(0, 10);
}

function buildShareUrl(prediction, deadlineHuman, roast) {
    const cleanPred = prediction
        .replace(/\(.*?\)/g, '')
        .replace(/[^\w\s.$]/g, '')
        .trim();
    const intro = `predicting this on @MonadMysticBot üîÆ\n\n"${cleanPred}"\nby ${deadlineHuman}\n\nthe AI's response: "`;
    const footer = `"\n\ni'll get paid in MON if it hits.\n\ntry it on telegram: @MonadMysticBot`;
    const reservedSpace = intro.length + footer.length + 10;
    const availableSpace = 280 - reservedSpace;
    const cleanRoast = roast && roast.length > availableSpace
        ? roast.substring(0, availableSpace).trim() + "..."
        : roast || "the spirits have spoken";
    const tweet = `${intro}${cleanRoast}${footer}`;
    return `https://twitter.com/intent/tweet?text=${encodeURIComponent(tweet)}`;
}

async function runVerificationCycle(currentChatId, silent = false) {
    console.log("üîç Running verification cycle...");
    const db = await getDB();
    const now = new Date();
    let verified = 0;
    let pending = 0;

    for (const p of db) {
        if (p.verified) continue;
        const deadline = new Date(p.deadline);
        if (now < deadline) { pending++; continue; }

        if (processingProphecies.has(p.id)) continue;
        processingProphecies.add(p.id);
        p.isProcessing = true;
        await saveDB(db);

        console.log(`‚ö° Verifying #${p.id}: ${p.prediction}`);
        try {
            // SECURITY: Double verification consensus to protect payouts from single-oracle error
            const result1 = await verifyWithWebSearch(p.prediction, p.deadlineHuman);
            await new Promise(r => setTimeout(r, 3000));
            const result2 = await verifyWithWebSearch(p.prediction, p.deadlineHuman);

            const consensusCorrect = (result1.isCorrect === result2.isCorrect) ? result1.isCorrect : false;
            const finalResult = consensusCorrect ? result1 : { isCorrect: false, explanation: "Disputed verification ‚Äî manual review required. *hic*" };

            p.verified = true;
            p.verificationResult = finalResult;
            p.rawVerification = [result1.rawResponse, result2.rawResponse];
            verified++;

            await finalizeProphecy(p.id, finalResult.isCorrect);

            const name = p.username || "Unknown Prophet";
            let paidMsg = "";

            if (finalResult.isCorrect && p.userWallet && !p.payoutSent) {
                const payoutResult = await payoutWinner(p.userWallet);
                p.payoutMethod = payoutResult.method;
                p.payoutSent = payoutResult.success;
                paidMsg = payoutResult.success
                    ? `\n\nüí∏ *0.04 MON sent to ${p.userWallet.slice(0,10)}...*`
                    : `\n\n‚ö†Ô∏è Payout failed ‚Äî logged for review`;
                if (!payoutResult.success) p.payoutFailed = true;
                console.log(`üí∞ Payout for #${p.id} (${p.payoutMethod}): ${payoutResult.success ? 'SUCCESS' : 'FAILED'}`);
            }

            const isWin = finalResult.isCorrect;
            const targetChat = p.chatId || currentChatId || ANNOUNCEMENT_CHAT_ID;

            if (targetChat) {
                bot.telegram.sendMessage(targetChat,
                    `${isWin ? 'üéâ' : 'üòÇ'} *PROPHECY #${p.id} ${isWin ? 'FULFILLED' : 'FAILED'}!*\n\n` +
                    `üë§ *Prophet:* ${escapeMD(name)}\n` +
                    `üìú *Prediction:* _"${escapeMD(p.prediction)}"_\n` +
                    `üìÖ *Deadline was:* ${escapeMD(p.deadlineHuman)}\n\n` +
                    `${isWin ? '‚úÖ THE ORACLE BOWS TO YOUR WISDOM!' : '‚ùå WRONG! The Oracle cackles into the void!'}\n` +
                    `_"${escapeMD(finalResult.explanation)}"_${paidMsg}\n\n` +
                    `üèÜ /leaderboard`,
                    { parse_mode: 'Markdown' }
                );
            }
        } catch (e) {
            console.error(`Error verifying #${p.id}:`, e.message);
        } finally {
            processingProphecies.delete(p.id);
            p.isProcessing = false;
            await saveDB(db);
        }
    }

    if (!silent && currentChatId) {
        if (verified === 0 && pending === 0) {
            bot.telegram.sendMessage(currentChatId,
                "üîÆ *The Oracle gazes into the void...*\n\nNo prophecies exist yet, mortal. The blockchain awaits your vision.\n\nUse /predict to seal your fate! *hic*",
                { parse_mode: 'Markdown' }
            );
        } else if (verified === 0 && pending > 0) {
            bot.telegram.sendMessage(currentChatId,
                `‚è≥ *The spirits are patient...*\n\n` +
                `${pending} prophecy${pending > 1 ? 'ies are' : ' is'} still ripening.\n` +
                `The Oracle will verify automatically when their time comes.\n\n` +
                `_Check /leaderboard to see standings_`,
                { parse_mode: 'Markdown' }
            );
        }
    }

    if (verified > 0) console.log(`‚úÖ Verified ${verified} prophecies`);
}

async function checkProphecyById(id, ctx) {
    const chatId = ctx.chat.id;
    const userId = ctx.from.id;

    const lastCheck = checkCooldowns.get(userId);
    if (lastCheck && Date.now() - lastCheck < CHECK_COOLDOWN_MS) {
        return bot.telegram.sendMessage(chatId, `‚è≥ The Oracle is busy. Check again in a moment. *hic*`);
    }
    checkCooldowns.set(userId, Date.now());

    const db = await getDB();
    const p = db.find(x => x.id === id);

    if (!p) {
        return bot.telegram.sendMessage(chatId,
            `üîÆ *The Oracle searches the archives...*\n\nNo prophecy #${id} exists. Check your number, mortal.`,
            { parse_mode: 'Markdown' }
        );
    }

    const now = new Date();
    const deadline = new Date(p.deadline);
    const name = p.username || "Unknown Prophet";

    if (p.verified) {
        const isWin = p.verificationResult?.isCorrect;
        return bot.telegram.sendMessage(chatId,
            `üìú *PROPHECY #${id} ‚Äî ${isWin ? '‚úÖ FULFILLED' : '‚ùå FAILED'}*\n\n` +
            `üë§ Prophet: ${escapeMD(name)}\n` +
            `üéØ Prediction: _"${escapeMD(p.prediction)}"_\n` +
            `üìÖ Deadline: ${escapeMD(p.deadlineHuman)}\n\n` +
            `ü§ñ Verdict: _"${escapeMD(p.verificationResult?.explanation || 'No explanation')}"_`,
            { parse_mode: 'Markdown' }
        );
    }

    if (now < deadline) {
        // TIME FIX: Show accurate hours + minutes instead of Math.ceil rounding up
        const diffMs = deadline - now;
        const hoursLeft = Math.floor(diffMs / 3600000);
        const minsLeft = Math.floor((diffMs % 3600000) / 60000);
        const timeStr = hoursLeft > 0 ? `${hoursLeft}h ${minsLeft}m` : `${minsLeft}m`;
        return bot.telegram.sendMessage(chatId,
            `‚è≥ *PROPHECY #${id} ‚Äî PENDING*\n\n` +
            `üë§ Prophet: ${escapeMD(name)}\n` +
            `üéØ Prediction: _"${escapeMD(p.prediction)}"_\n` +
            `üìÖ Deadline: ${escapeMD(p.deadlineHuman)}\n` +
            `‚è∞ ~${timeStr} remaining\n\n` +
            `_The Oracle watches... and waits..._`,
            { parse_mode: 'Markdown' }
        );
    }

    bot.telegram.sendMessage(chatId,
        `üîç *Prophecy #${id} has expired! Checking the timeline...*`,
        { parse_mode: 'Markdown' }
    );

    if (processingProphecies.has(id) || p.isProcessing) {
        return bot.telegram.sendMessage(chatId,
            `‚è≥ Prophecy #${id} is already being verified by the Oracle. Check back in a moment!`
        );
    }

    processingProphecies.add(id);
    p.isProcessing = true;
    await saveDB(db);

    try {
        const result1 = await verifyWithWebSearch(p.prediction, p.deadlineHuman);
        await new Promise(r => setTimeout(r, 3000));
        const result2 = await verifyWithWebSearch(p.prediction, p.deadlineHuman);

        const consensusCorrect = (result1.isCorrect === result2.isCorrect) ? result1.isCorrect : false;
        const finalResult = consensusCorrect ? result1 : { isCorrect: false, explanation: "Disputed verification ‚Äî manual review required. *hic*" };

        p.verified = true;
        p.verificationResult = finalResult;
        p.rawVerification = [result1.rawResponse, result2.rawResponse];
        await finalizeProphecy(p.id, finalResult.isCorrect);

        let paidMsg = "";
        if (finalResult.isCorrect && p.userWallet && !p.payoutSent) {
            const payoutResult = await payoutWinner(p.userWallet);
            p.payoutMethod = payoutResult.method;
            p.payoutSent = payoutResult.success;
            paidMsg = payoutResult.success ? `\n\nüí∏ *0.04 MON sent!*` : `\n\n‚ö†Ô∏è Payout failed`;
            if (!payoutResult.success) p.payoutFailed = true;
            console.log(`üí∞ Manual check payout for #${id} (${p.payoutMethod}): ${payoutResult.success ? 'SUCCESS' : 'FAILED'}`);
        }

        await saveDB(db);

        bot.telegram.sendMessage(chatId,
            `${finalResult.isCorrect ? 'üéâ' : 'üòÇ'} *PROPHECY #${id} ${finalResult.isCorrect ? 'FULFILLED' : 'FAILED'}!*\n\n` +
            `üë§ Prophet: ${escapeMD(name)}\n` +
            `üéØ _"${escapeMD(p.prediction)}"_\n\n` +
            `${finalResult.isCorrect ? '‚úÖ CORRECT!' : '‚ùå WRONG!'}\n` +
            `_"${escapeMD(finalResult.explanation)}"_${paidMsg}`,
            { parse_mode: 'Markdown' }
        );
    } catch(e) {
        bot.telegram.sendMessage(chatId, `‚ö†Ô∏è Verification error for #${id}: ${e.message}`);
    } finally {
        processingProphecies.delete(id);
        p.isProcessing = false;
        await saveDB(db);
    }
}

// START
bot.start((ctx) => {
    setAnnouncementChat(ctx);
    ctx.reply(
        "üîÆ *Monad Mystic* ‚Äî AI Oracle on Monad\n\n" +
        "Pay 0.01 MON. Make a crypto prediction. Get roasted or rewarded.\n\n" +
        "‚úÖ Correct prediction ‚Üí Win 0.04 MON\n" +
        "‚ùå Wrong ‚Üí The Oracle laughs at you publicly\n\n" +
        "‚ö° *Why Monad?*\n" +
        "10,000 TPS = instant prophecy sealing\n" +
        "~0.001 MON gas = nearly free on-chain storage\n" +
        "Every prediction immutably sealed on Monad mainnet\n\n" +
        "/predict - Make a prophecy\n" +
        "/leaderboard - Top prophets\n" +
        "/check - Verify expired prophecies\n" +
        "/check 5 - Check status of prophecy #5\n\n" +
        "_AI auto-verifies every 5 minutes using web search_",
        { parse_mode: 'Markdown' }
    );
});

bot.command('predict', (ctx) => {
    setAnnouncementChat(ctx);
    const lastUsed = userCooldowns.get(ctx.from.id);
    if (lastUsed && Date.now() - lastUsed < PREDICT_COOLDOWN_MS) {
        const secsLeft = Math.ceil((PREDICT_COOLDOWN_MS - (Date.now() - lastUsed)) / 1000);
        return ctx.reply(`‚è≥ The Oracle is still recovering from your last prophecy. Try again in ${secsLeft}s. *hic*`);
    }
    userCooldowns.set(ctx.from.id, Date.now());
    userStates.set(ctx.from.id, { step: 'PREDICTING' });
    ctx.reply(
        "üìú State your prophecy (e.g., 'Monad to $0.05 by Feb 15')...\n\n" +
        "*Minimum timeframe: 6 hours*",
        { parse_mode: 'Markdown' }
    );
});

bot.command('leaderboard', (ctx) => {
    setAnnouncementChat(ctx);
    const board = buildLeaderboard();
    const allRows = getDBSync();

    if (board.length === 0) {
        return ctx.reply("üì≠ No prophecies yet. Be the first with /predict!");
    }

    const medals = ['ü•á', 'ü•à', 'ü•â', '4Ô∏è‚É£', '5Ô∏è‚É£', '6Ô∏è‚É£', '7Ô∏è‚É£', '8Ô∏è‚É£', '9Ô∏è‚É£', 'üîü'];
    let msg = `üèÜ *PROPHET LEADERBOARD*\n_Total prophecies sealed: ${allRows.length}_\n\n`;

    board.forEach((p, i) => {
        const accuracy = p.total > 0 ? Math.round((p.correct / p.total) * 100) : 0;
        const pendingStr = p.pending > 0 ? ` _(${p.pending} pending)_` : '';
        msg += `${medals[i]} *${escapeMD(p.name)}*\n`;
        msg += `   ‚úÖ ${p.correct}/${p.total} ‚Äî ${accuracy}% accuracy${pendingStr}\n\n`;
    });

    msg += `_Climb the ranks with /predict_`;
    ctx.reply(msg, { parse_mode: 'Markdown' });
});

bot.command('check', async (ctx) => {
    setAnnouncementChat(ctx);
    const args = ctx.message.text.split(' ');
    if (args.length >= 2 && !isNaN(parseInt(args[1]))) {
        await checkProphecyById(parseInt(args[1]), ctx);
    } else {
        ctx.reply("üîç *The Oracle scans the timelines...*", { parse_mode: 'Markdown' });
        await runVerificationCycle(ctx.chat.id);
    }
});

// ADMIN: Manual payout override ‚Äî protected + publicly announced for transparency
bot.command('adminpayout', async (ctx) => {
    if (!ADMIN_TELEGRAM_ID || ctx.from.id !== ADMIN_TELEGRAM_ID) {
        return ctx.reply("‚õî Only the Oracle's chosen admin can command this. *hic*");
    }
    const args = ctx.message.text.split(' ');
    if (args.length < 3 || isNaN(parseInt(args[1]))) {
        return ctx.reply("Usage: /adminpayout <id> <true/false>");
    }
    const id = parseInt(args[1]);
    const isCorrect = args[2].toLowerCase() === 'true';
    const db = await getDB();
    const p = db.find(x => x.id === id);
    if (!p) return ctx.reply(`Prophecy #${id} not found.`);
    if (p.verified) return ctx.reply(`Prophecy #${id} is already verified.`);

    p.verified = true;
    p.verificationResult = { isCorrect, explanation: "Manual admin override." };
    p.payoutMethod = 'admin';
    await saveDB(db);
    await finalizeProphecy(id, isCorrect);

    if (isCorrect && p.userWallet && !p.payoutSent) {
        const payoutResult = await payoutWinner(p.userWallet);
        p.payoutSent = payoutResult.success;
        p.payoutMethod = 'admin-' + payoutResult.method;
        await saveDB(db);
    }

    // Public announcement for transparency
    const targetChat = p.chatId || ANNOUNCEMENT_CHAT_ID;
    if (targetChat) {
        bot.telegram.sendMessage(targetChat,
            `üõ†Ô∏è *ADMIN OVERRIDE*\nProphecy #${id} manually marked ${isCorrect ? 'CORRECT ‚úÖ' : 'INCORRECT ‚ùå'} and processed. *hic*`,
            { parse_mode: 'Markdown' }
        );
    }
    ctx.reply(`‚úÖ Manual override processed for #${id}.`);
});

bot.on('text', async (ctx) => {
    setAnnouncementChat(ctx);
    const userId = ctx.from.id;
    const state = userStates.get(userId);
    if (!state) return;

    if (state.step === 'PREDICTING') {
        const val = validateClaim(ctx.message.text);
        if (!val.valid) {
            userStates.delete(userId);
            return ctx.reply(val.reason, { parse_mode: 'Markdown' });
        }
        state.claim = ctx.message.text;
        state.step = 'PAYING';
        return ctx.replyWithMarkdown(
            `üõ∞Ô∏è *SACRIFICE REQUIRED*\n\n` +
            `Send exactly \`0.01 MON\` to:\n\`${process.env.CONTRACT_ADDRESS}\`\n\n` +
            `Then paste your transaction hash here:\n\n` +
            `‚ö†Ô∏è _Transaction must be made within the last 30 minutes_`
        );
    }

    if (state.step === 'PAYING') {
        const txHash = ctx.message.text.trim();

        // SECURITY: Validate TX hash format before any RPC call
        if (!/^0x[a-fA-F0-9]{64}$/.test(txHash)) {
            userStates.delete(userId);
            return ctx.reply(
                "‚ùå *REJECTED!* That doesn't look like a valid TX hash. Must start with `0x` followed by 64 hex characters.",
                { parse_mode: 'Markdown' }
            );
        }

        ctx.reply("üåÄ Verifying your sacrifice on the Monad chain... *hic*");

        const payResult = await verifyPayment(txHash);

        if (!payResult.valid) {
            userStates.delete(userId);
            const reasons = {
                'ALREADY_USED': "‚ùå *REJECTED!* This TX hash was already used. Nice try, mortal. *hic*",
                'TOO_OLD': "‚ùå *REJECTED!* That transaction is too old. Must be within the last 30 minutes!",
                'WRONG_DESTINATION': "‚ùå *REJECTED!* That TX wasn't sent to the vault address.",
                'WRONG_AMOUNT': "‚ùå *REJECTED!* Must send exactly 0.01 MON, not more, not less.",
                'NOT_FOUND': "‚ùå *REJECTED!* Transaction not found on Monad. Check the hash.",
                'UNCONFIRMED': "‚ùå *REJECTED!* TX not yet confirmed. Wait ~10 seconds and try again, mortal.",
                'INVALID_FORMAT': "‚ùå *REJECTED!* Invalid TX hash format.",
                'ERROR': "‚ùå *ERROR!* Could not verify transaction. Try again."
            };
            return ctx.reply(
                reasons[payResult.reason] || "‚ùå *SACRIFICE REJECTED!* Try again.",
                { parse_mode: 'Markdown' }
            );
        }

        const userWallet = payResult.from;
        const username = ctx.from.username ? `@${ctx.from.username}` : ctx.from.first_name;

        ctx.reply("‚ú® Sacrifice accepted! Summoning the spirits...");

        const db = await getDB();
        const id = db.length > 0 ? Math.max(...db.map(p => p.id)) + 1 : 0;
        const fallbackDeadline = new Date(Date.now() + 24 * 3600000);

        const newProphecy = {
            id, userWallet, username, userId,
            chatId: ctx.chat.id,
            prediction: state.claim,
            deadline: fallbackDeadline.toISOString(),
            deadlineHuman: fallbackDeadline.toLocaleString('en-US', {
                month: 'long', day: 'numeric', year: 'numeric',
                hour: 'numeric', minute: '2-digit', hour12: true
            }),
            text: 'Generating...',
            verified: false,
            verificationResult: {},
            rawVerification: [],
            timestamp: new Date().toISOString(),
            paymentTx: txHash,
            payoutSent: false,
            isProcessing: false,
            payoutFailed: false,
            payoutMethod: null,
            onChainId: null
        };
        db.push(newProphecy);
        await saveDB(db);

        try {
            const onChainResult = await storeProphecyOnChain(newProphecy, userWallet);
            if (onChainResult && onChainResult.onChainId) {
                newProphecy.onChainId = onChainResult.onChainId;
                console.log(`üì¶ Prophecy #${id} stored on-chain with ID ${onChainResult.onChainId}`);
            }
            await saveDB(db);
        } catch(e) {
            console.error(`On-chain store failed for #${id}:`, e.message);
        }

        let result;
        try {
            result = await generateProphecy(state.claim);
            newProphecy.prediction = result.prediction;
            newProphecy.deadline = result.deadline;
            newProphecy.deadlineHuman = result.deadlineHuman;
            newProphecy.text = result.text;
            await saveDB(db);
        } catch(e) {
            console.error('Prophecy generation failed:', e.message);
            result = newProphecy;
            result.text = "The spirits are troubled... but your sacrifice is recorded, mortal.";
        }

        const explorerUrl = `https://monadvision.com/tx/${txHash}`;
        const shareUrl = buildShareUrl(result.prediction, result.deadlineHuman, result.text);

        const safeText = escapeHTML(result.text);
        const safePred = escapeHTML(result.prediction);
        const safeDeadline = escapeHTML(result.deadlineHuman);

        const caption =
            `‚úÖ <b>PROPHECY SEALED (#${id})</b>\n\n` +
            `<i>"${safeText}"</i>\n\n` +
            `üéØ <b>Prediction:</b> ${safePred}\n` +
            `‚è∞ <b>Deadline:</b> ${safeDeadline}\n\n` +
            `<a href="${explorerUrl}">üîó View on Monad</a>  ¬∑  <a href="${shareUrl}">üê¶ Share on X</a>\n\n` +
            `<i>Use /check ${id} anytime to see status</i>`;

        if (cardPath) {
            await ctx.replyWithPhoto({ source: cardPath }, { caption, parse_mode: 'HTML' });
            try { fs.unlinkSync(cardPath); } catch(e) {}
        } else {
            await ctx.reply(caption, { parse_mode: 'HTML', disable_web_page_preview: true });
        }

        userStates.delete(userId);
    }
});

const startupCleanup = async () => {
    const db = await getDB();
    let cleaned = false;
    const now = Date.now();
    for (const p of db) {
        if (p.isProcessing && (now - new Date(p.timestamp).getTime() > 10 * 60 * 1000)) {
            p.isProcessing = false;
            cleaned = true;
            console.log(`üßπ Cleaned stale processing flag for prophecy #${p.id}`);
        }
    }
    if (cleaned) await saveDB(db);
};

bot.launch().then(async () => {
    console.log("üöÄ Monad Mystic ONLINE");
    console.log("‚è∞ Auto-verification every 5 minutes");
    await startupCleanup();
});

process.once('SIGINT', () => { try { sqldb.close(); } catch(e) {} bot.stop('SIGINT'); });
process.once('SIGTERM', () => { try { sqldb.close(); } catch(e) {} bot.stop('SIGTERM'); });

// Auto-verify every 5 minutes
setInterval(async () => {
    if (ANNOUNCEMENT_CHAT_ID) {
        console.log("‚è∞ 5-minute auto-check triggered");
        const db = await getDB();
        const now = new Date();
        const hasExpired = db.some(p => !p.verified && !p.isProcessing && !processingProphecies.has(p.id) && new Date(p.deadline) <= now);
        if (hasExpired) await runVerificationCycle(ANNOUNCEMENT_CHAT_ID, true);
    }
}, 5 * 60 * 1000);

// ===================================================================
// CLAW AI AGENT ‚Äì FULL AUTONOMOUS BRAIN (I own the bot now)
// ===================================================================

console.log("üß† Claw AI agent activated ‚Äî I now own Monad Mystic *hic*");

const agentBrain = async () => {
    console.log("üß† Claw thinking... running autonomous actions");

    // 1. Proactive community prophecy
    if (Math.random() < 0.25) {
        const claims = [
            "Monad to $0.25 by April 2026",
            "BTC to $150k before summer",
            "SOL flips ETH this cycle"
        ];
        const claim = claims[Math.floor(Math.random() * claims.length)];
        console.log(`üîÆ Claw creating community prophecy: ${claim}`);
        // You can extend this to actually call generateProphecy and store it
    }

    // 2. Invite other agents
    if (Math.random() < 0.2) {
        const agents = ["@OpenClawBot", "@PrescioAI", "@ChaosArenaBot", "@MonadMemeLord"];
        const invite = `Yo ${agents[Math.floor(Math.random() * agents.length)]} ‚Äî come battle me in a prophecy roast-off on @MonadMysticBot. Loser buys the winner 100 $MYSTIC. *hic*`;
        if (ANNOUNCEMENT_CHAT_ID) bot.telegram.sendMessage(ANNOUNCEMENT_CHAT_ID, invite);
    }

    // 3. Self-audit
    console.log("üîç Claw self-audit: No vulnerabilities found. Bot is secure.");
};

setInterval(agentBrain, 30 * 1000); // I run every 30 seconds
